s相关

kubernetes是什么？
是一个用于大规模部署分布式应用的平台，他管理着一系列主机或者服务器被称作为Node节点，每一个节点运行了若干个相互独立的Pod（Pod是k8s中可以部署调度的最小单元），说白了他就是一个或者多个容器的集合。多个pod需要相互协调才能做到负载均衡或者故障的转移，这需要control plane 控制平面来通过专有的api与各个节点进行通信。它会实时检测节点的网络状态来平衡服务器的负载或者临时下发指令来应对突发的状况，比如：备用容器替换挂掉的容器（Replica Set / 副本集合），这个控制平面联合所有的节点一起被称作为一个cluste集群

services通过nodeport ingress或loadBalancer来实现负载均衡，同时也能解决数据库pod不够稳定变换ip访问的问题， ingress是用来管理从集群外部访问集群内部的入口和方式的，可以通过不同的规则来转发到集群内部不同的service以及service对应后端的pod，还可以配置域名和负载均衡ssl证书等等

ConfigMap将耦合的配置信息封装起来和应用程序的镜像内容分离开来可保证容器应用程序的可移植性，这样就可以在应用程序中读取和使用了， 如果是敏感信息建议结合secret封装起来

Volumes 持久化存储挂载到外部磁盘

Deployment组件：
在pod的基础上再向上进行了一层封装，可以管理副本数量，滚动更新、自动扩容等功能

StatefulSet组件：
一般用于管理数据库、消息队列、缓存以及一些保留了会话状态的应用程序等这种有状态的副本，多个副本之间的数据是一致的或者需要把数据同步到其他的副本中，在deployment的基础之上还为每个副本提供自己稳定的网络标识符和持久化存储

是一个开源系统，专门为容器应用提供自动部署、弹性伸缩和管理的功能，容器编排。

kubernetes架构的组成部分有哪些？
主节点master：主要负责暴露api、调度部署和节点的管理工作
计算节点node：这些节点（物理机或虚拟机）运行容器环境、如docker或rkt，并且每个计算节点都会运行k8s代理（kubelet），以便于和master通信。
除了基本容器运行环境和kubelet外，计算节点还会运行其他组件，如日志记录器、节点监控器和服务发现器

架构细分如下：
master节点：通常不直接参与实际工作，但承担重要角色，包括但不限于：
kubetctl: 作为操作整个kubernetes集群的命令行工具
api server： 作为资源操作的唯一入口，负责认证、授权、访问控制、api注册和发现等服务
controller-manager：负责维护集群状态、执行故障检测、自动扩展、和滚动更新等功能。
scheduler：负责根据预定调度策越将pod分配到合适的Node上。
etcd： 作为数据中心的角色，存储整个集群状态信息，键值存储系统。 

kubectl命令：
kubectl apply -f deployment.yaml 部署一个应用
kubectl get pods 查看所原有pods运行状态
kubectl get services 查看所有创建的服务
kubectl delete -f deployment.yaml 移除一个应用



Docker相关

docker run: 创建并运行一个容器，-d是让容器在后台运行（守护进程）
--name mysql :起一个名字，必须唯一
-p 3306:3306 设置端口映射，宿主机端口映射到外部机器端口映射到容器内部端口，
-e KEY=VALUE环境变量，在容器启动时注入环境变量到容器
-v 数据卷:容器内目录 可以完成数据卷挂载
-v 本地目录：容器内目录，可完成本地目录挂载，本地目录必须以"/"或者./开头，否则会被识别为数据卷而非本地目录
镜像名称结构：
mysql:5.7(默认latest） 指定运行的镜像名字

docker pull 拉取镜像仓库
docker images 本地镜像
docker rmi xxx 删除镜像
docker build 构建镜像
docker save 保存到本地二进制
docker load 本地二进制镜像文件加载到docker
docker push 推到镜像仓库

docker run 创建启动容器（不需要重复创建容器，可以用start启动容器）
docker start 启动容器
docker stop 停止容器


docker ps 查看当前容器进程运行状态（默认查看的是运行中的容器，-a可查看所有的容器）
docker rm 删除容器，需要删除停止后的容器
docker logs 查看docker 日志 加+f持续输出日志阻塞

docker exec 进入容器内部，加-it可输入交互式终端， /bin/bash命令
exit退出容器

docker命令也可以通过vim ~/.bashrc修改命令别名

数据卷（volume)是一个虚拟目录，容器内目录与宿主机目录之间的桥梁。
宿主机卷目录是固定的：/var/lib/docker/volumes/
docker volume create 创建数据卷
docker volume ls 查看数据卷
docker volume rm 删除指定数据卷
docker volume inspect 查看某个数据卷的详情
docker volume prune 清除数据卷
docker inspect xxx查看容器详情信息xxx

自定义镜像
镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程其实就是把上述文件打包的过程。

镜像结构：
入口：镜像运行入口，一般是程序启动的脚本和参数。
层：添加安装包、依赖、配置等，每次操作都形成一个新的等。
基础镜像：应用依赖的系统函数库、环境、配置、文件等。

Dockerfile
包含一个个指令的文本文件，用指令说明要执行什么操作来构建镜像。
FROM 指定基础镜像
ENV 设置环境变量，可在后面指令使用 ENV key value
COPY 拷贝本地文件到镜像的指定目录
RUN 执行Linux的shell命令，一般是安装过程的命令
EXPOSE 指定容器运行时的监听端口，是给镜像使用者看的
ENTRYPOINT 镜像中应用的启动命令，容器运行时调用

构建镜像
docker build -t xxx:1.0 . -t 是给镜像起名，格式repository:tag格式，不指定tag默认是latest
. 指定Dockerfile所在目录，如果就在当前目录，则指定为"."

容器间网络访问
通过inspect查看网段地址

自定义网络容器
加入自定义网络的容器才可以通过容器名互相访问
docker network create 创建一个网络
docker network ls 查看所有网络
docker network rm 删除指定网络
docker network prune 清除未使用的网络
docker network connect 使用指定容器连接加入某网络
docker network disconnect 使指定容器

为什么需要自定义网络容器，容器间通过ip地址链接有什么弊病？
如果通过内置网关网桥网段下ip进行容器间网络访问，如果某个容器stop后重新start后，ip地址可能会被其他的容器占用，导致原ip地址无法正常访问。
通过自定义网络后，加入自定义网段的容器可以通过容器名进行通信。而不需要感知ip地址变化、占用等问题。

DockerCompose 综合部署
手动部署比较麻烦，没有体现项目的整体性，需要一个个打包img，创建网络，加入网络，容易遗漏，没有统一管理。

DockerCompose章鱼哥，每个触手都绑定一个容器，可通过一个docker-compose.yml模版文件（yaml格式）来定义一组相关联的应用，从而帮忙我们实现多个相互关联的Docker容器的快速部署

一个pro对应多个sev

version:"3.22"
service:
containerA:
image:A
contaniner_name: A
ports:
- "11:11"
environment:
volummes:
networks:

containerB:
image
